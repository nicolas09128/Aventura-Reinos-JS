<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: script.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: script.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Las clases ya est√°n disponibles globalmente (cargadas por etiquetas &lt;script> en el HTML)
import { Enemigos, JefeFinal } from './js/enemigos.js';
import { Jugadores } from './js/Jugadores.js';
import { Mercado } from './js/mercado.js';
import { batalla, categorizePlayers, mostrarRanking, mostrarReporteCompleto } from './js/Ranking.js';
// Crear instancia del mercado
const mercado = new Mercado();

/**
 * Devuelve la ruta de la imagen para un producto seg√∫n su nombre o tipo.
 * Mapeo heur√≠stico que intenta emparejar por palabras clave del nombre
 * y, si no encuentra, utiliza el tipo del producto.
 * @param {Object} producto - Producto con propiedades `nombre` y `tipo`.
 * @returns {string} Ruta relativa de la imagen a usar.
 */
function getProductImage(producto) {
    const name = (producto.nombre || '').toLowerCase();
    const tipo = (producto.tipo || '').toLowerCase();

    // Mapeos por nombre (casos espec√≠ficos seg√∫n archivos en /img)
    if (name.includes('espada')) return './img/espada.png';
    if (name.includes('hacha')) return './img/hacha.png';
    if (name.includes('escudo') || name.includes('escudo antiguo')) return './img/escudo.png';
    if (name.includes('legendario') &amp;&amp; name.includes('escudo')) return './img/escudoRaro.png';
    if (name.includes('pocion')) return './img/Pocion.png';
    if (name.includes('revivir')) return './img/revivir.png';

    // Mapeos por tipo
    if (tipo === 'arma') return './img/espada.png';
    if (tipo === 'armadura') return './img/armadura.png';
    if (tipo === 'consumible') return './img/Pocion.png';

    // Fallback gen√©rico
    return './img/p1.png';
}

// Productos en formato de tienda. Se construyen desde el mercado.
var products = [];
function rebuildProductsFromMercado() {
    products = [];
    for (var i = 0; i &lt; mercado.listaProductos.length; i++) {
        var producto = mercado.listaProductos[i];
        products.push({
            id: i + 1,
            name: producto.nombre,
            price: producto.precio,
            image: getProductImage(producto),
            type: producto.tipo,
            rareza: producto.rareza,
            bonus: producto.bonus,
            productoOriginal: producto
        });
    }
}
rebuildProductsFromMercado();

/**
 * Aplica un 20% de descuento a un producto aleatorio del mercado
 * y vuelve a renderizar la tienda para que se vea el nuevo precio.
 * No devuelve nada, actualiza el estado del `mercado` y la UI.
 * @returns {void}
 */
function applyRandomDiscount20() {
    const items = mercado.listaProductos;
    if (!items || items.length === 0) return;
    var idx = Math.floor(Math.random() * items.length);
    var producto = items[idx];
    producto.aplicarDescuento(20);

    // Reconstruir productos y UI
    rebuildProductsFromMercado();
    initializeShop();
    updateUI();

    try {
        alert('Se aplic√≥ un 20% de descuento a: ' + producto.nombre + ' (nuevo precio: ' + (producto.precio / 100).toFixed(2) + '‚Ç¨)');
    } catch (e) {
        console.log('Descuento aplicado a:', producto.nombre, 'nuevo precio:', producto.precio);
    }
}

// Estado del juego
var initialMoney = 3000; // c√©ntimos
var gameState = {
    money: initialMoney,
    selectedProducts: [],
    purchasedProducts: [],
};

// Estado del jugador
const player = new Jugadores('Atreus');

// Enemigos (crear 5 enemigos)
var enemies = [
    new Enemigos('Enemigo', 'Goblin', 20, 50),
    new Enemigos('Enemigo', 'Lobo', 30, 60),
    new Enemigos('Enemigo', 'Orco', 40, 80),
    new Enemigos('Enemigo', 'Demonio', 60, 100),
    new JefeFinal('Drag√≥n', 55, 120, 'Llamarada', 2.0)
];

let selectedEnemy = null;
let enemiesQueue = []; // Cola de 3 enemigos aleatorios
let currentEnemyIndex = 0; // √çndice del enemigo actual (1, 2, 3)

/**
 * Muestra la escena indicada ocultando las dem√°s. Reinicia animaciones
 * y lanza efectos (confetti/emoji) en la escena final.
 * @param {string} id - ID del contenedor `.scene` a mostrar (por ejemplo 'scene-1').
 * @returns {void}
 */
function showScene(id) {
    var scenes = document.querySelectorAll('.scene');
    for (var i = 0; i &lt; scenes.length; i++) {
        scenes[i].style.display = 'none';
    }
    
    // Mostrar la escena solicitada
    const el = document.getElementById(id);
    if (el) {
        el.style.display = 'block';

        // Si es la escena de batalla, aplicar slide-in a las im√°genes
        if (id === 'scene-5') {
            const pImg = document.getElementById('player-image-battle');
            const eImg = document.getElementById('enemy-image-battle');
            if (pImg) {
                pImg.classList.remove('slide-in-left');
                void pImg.offsetWidth; // force reflow to restart animation
                pImg.classList.add('slide-in-left');
            }
            if (eImg) {
                eImg.classList.remove('slide-in-right');
                void eImg.offsetWidth;
                eImg.classList.add('slide-in-right');
            }
        }

        // Si es la escena final, lanzar confetti o emoji seg√∫n categor√≠a
        if (id === 'scene-6' &amp;&amp; typeof confetti === 'function') {
            var puntos = player.puntos || 0;
            var categoria = puntos >= 100 ? 'pro' : 'rookie';
            if (categoria === 'rookie') {
                launchPoopEmojis();
            } else {
                confetti({ particleCount: 120, spread: 70, origin: { y: 0.35 } });
            }
        }
    } else {
        console.error('Elemento no encontrado:', id); 
    }
}

// Inicializaci√≥n
window.addEventListener('load', () => {
    // Inicializar componentes
    initializeShop();
    initializeInventory();
    updateUI();

    var toShopBtn = document.getElementById('to-shop-btn');
    if (toShopBtn) {
        toShopBtn.onclick = function() {
            applyRandomDiscount20();
            showScene('scene-2');
        };
    }
    document.getElementById('reset-btn').addEventListener('click', resetSelection);
    document.getElementById('buy-btn').addEventListener('click', processPurchase);
    document.getElementById('shop-continue-btn').addEventListener('click', () => { 
        updateUI(); 
        showScene('scene-3'); 
    });
    document.getElementById('to-battle-btn').addEventListener('click', () => {
        populateEnemySelector();
        showScene('scene-4');
    });
    document.getElementById('scene-4-continue-btn').addEventListener('click', startBattleSequence);
    document.getElementById('scene-4-back-btn').addEventListener('click', () => {
        showScene('scene-3');
    });
    document.getElementById('fight-btn').addEventListener('click', fight);
    const backToMenuBtn = document.getElementById('back-to-menu-btn');
    if (backToMenuBtn) {
        backToMenuBtn.addEventListener('click', () => {
            enemiesQueue = [];
            currentEnemyIndex = 0;
            showScene('scene-3');
        });
    }
    document.getElementById('restart-btn').addEventListener('click', restartGame);

    showScene('scene-1');
    updateStatsDisplay();
});

/**
 * Renderiza los productos en la tienda (crea las tarjetas y botones).
 * Se llama siempre que cambian los productos o sus precios.
 */
function initializeShop() {
    const shopContainer = document.getElementById('shop-container');
    shopContainer.innerHTML = '';

    // Contenedor para los productos
    const productsGrid = document.createElement('div');
    productsGrid.className = 'products-grid';
    
    function displayProducts(productsToShow) {
        if (!productsToShow) productsToShow = products;
        productsGrid.innerHTML = '';
        for (var i = 0; i &lt; productsToShow.length; i++) {
            var product = productsToShow[i];
            var productElement = document.createElement('div');
            productElement.className = 'product';
            productElement.dataset.id = product.id;
            productElement.dataset.price = product.price;

            // Construir HTML del producto
            var bonusHtml = '';
            if (product.bonus &amp;&amp; typeof product.bonus === 'object') {
                for (var k in product.bonus) {
                    if (Object.prototype.hasOwnProperty.call(product.bonus, k)) {
                        bonusHtml += '&lt;span>' + k + ': +' + product.bonus[k] + '&lt;/span>';
                    }
                }
            } else {
                bonusHtml = String(product.bonus);
            }

            productElement.innerHTML = '\n                &lt;img src="' + product.image + '" alt="' + product.name + '" class="product-img">\n                &lt;div class="product-name">' + product.name + '&lt;/div>\n                &lt;div class="product-rareza">' + product.rareza + '&lt;/div>\n                &lt;div class="product-price">' + (product.price / 100).toFixed(2) + '‚Ç¨&lt;/div>\n                &lt;div class="product-bonus">' + bonusHtml + '&lt;/div>\n                &lt;div style="margin-top:8px;">\n                    &lt;button class="btn add-btn">' + (gameState.selectedProducts.indexOf(product.id) !== -1 ? 'Retirar' : 'A√±adir') + '&lt;/button>\n                &lt;/div>\n            ';

            // boton de a√±adir/retirar
            (function(prod, elem){
                var btn = elem.querySelector('.add-btn');
                if (btn) {
                    btn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        toggleProductSelection(prod.id);
                        if (gameState.selectedProducts.indexOf(prod.id) !== -1) {
                            elem.classList.add('added');
                            setTimeout(function(){ elem.classList.remove('added'); }, 900);
                        }
                        btn.textContent = (gameState.selectedProducts.indexOf(prod.id) !== -1) ? 'Retirar' : 'A√±adir';
                    });
                }

                elem.addEventListener('click', function() {
                    toggleProductSelection(prod.id);
                    var btn2 = elem.querySelector('.add-btn');
                    if (btn2) btn2.textContent = (gameState.selectedProducts.indexOf(prod.id) !== -1) ? 'Retirar' : 'A√±adir';
                });
            })(product, productElement);

            productsGrid.appendChild(productElement);
        }
    }

    // Mostrar todos los productos
    shopContainer.appendChild(productsGrid);
    displayProducts(products);
}

/**
 * Crea los 8 slots del inventario en la UI (vac√≠os inicialmente).
 */
function initializeInventory() {
    const inventoryContainer = document.getElementById('inventory-container');
    inventoryContainer.innerHTML = '';
    for (let i = 0; i &lt; 8; i++) {
        const itemElement = document.createElement('div');
        itemElement.className = 'item empty';
        itemElement.id = `inventory-slot-${i}`;
        inventoryContainer.appendChild(itemElement);
    }
}

/**
 * Alterna la selecci√≥n de un producto en la UI (a√±adir/retirar).
 * Actualiza el estado `gameState.selectedProducts` y la clase visual.
 * @param {number} productId - ID del producto a alternar
 */
function toggleProductSelection(productId) {
    // QUERYSELECTOR: selecciona un elemento HTML usando un selector CSS
    const productElement = document.querySelector(`.product[data-id="${productId}"]`);
    const product = products.find(p => p.id === productId);
    if (!productElement) return;

    // Alternar selecci√≥n: si ya est√° seleccionado, lo deselecciona
    var idx = gameState.selectedProducts.indexOf(productId);
    if (idx !== -1) {
        gameState.selectedProducts.splice(idx, 1);
        productElement.classList.remove('selected');
    } else {
        if (canAffordProduct(product.price)) {
            gameState.selectedProducts.push(productId);
            productElement.classList.add('selected');
        }
    }
    updateUI();
}

/**
 * Comprueba si el jugador puede permitirse un producto teniendo en cuenta
 * los productos ya seleccionados.
 * @param {number} price - Precio del producto en c√©ntimos
 * @returns {boolean}
 */
function canAffordProduct(price) {
    var totalSelectedPrice = 0;
    for (var i = 0; i &lt; gameState.selectedProducts.length; i++) {
        var id = gameState.selectedProducts[i];
        for (var j = 0; j &lt; products.length; j++) {
            if (products[j].id === id) {
                totalSelectedPrice += products[j].price;
                break;
            }
        }
    }
    return (totalSelectedPrice + price) &lt;= gameState.money;
}

/**
 * Actualiza la interfaz: dinero, botones, inventario y estad√≠sticas visibles.
 * Llama a funciones auxiliares para mantener la UI sincronizada con `gameState`.
 */
function updateUI() {
    document.getElementById('money-amount').textContent = `${(gameState.money / 100).toFixed(2)}‚Ç¨`;
    // Calcular total seleccionado
    var totalSelectedPrice = 0;
    for (var i = 0; i &lt; gameState.selectedProducts.length; i++) {
        var sid = gameState.selectedProducts[i];
        for (var j = 0; j &lt; products.length; j++) {
            if (products[j].id === sid) {
                totalSelectedPrice += products[j].price;
                break;
            }
        }
    }

    for (var p = 0; p &lt; products.length; p++) {
        var product = products[p];
        var productElement = document.querySelector('.product[data-id="' + product.id + '"]');
        if (!productElement) continue;
        var canAfford = (totalSelectedPrice + product.price &lt;= gameState.money) || (gameState.selectedProducts.indexOf(product.id) !== -1);
        if (!canAfford &amp;&amp; gameState.selectedProducts.indexOf(product.id) === -1) {
            productElement.classList.add('disabled');
        } else {
            productElement.classList.remove('disabled');
        }
        var btn = productElement.querySelector('.add-btn');
        if (btn) btn.textContent = (gameState.selectedProducts.indexOf(product.id) !== -1) ? 'Retirar' : 'A√±adir';
    }

    const buyButton = document.getElementById('buy-btn');
    buyButton.disabled = gameState.selectedProducts.length === 0;

    updateInventoryDisplay();
    updateStatsDisplay();
}

/**
 * Deselecciona todos los productos seleccionados y actualiza la UI.
 */
function resetSelection() {
    gameState.selectedProducts = [];
    document.querySelectorAll('.product').forEach(p => p.classList.remove('selected'));
    updateUI();
}

/**
 * Procesa la compra de los productos seleccionados: descuenta dinero,
 * a√±ade los objetos al inventario del jugador y actualiza la UI.
 */
function processPurchase() {
    if (gameState.selectedProducts.length === 0) return;
    
    // REDUCE: suma todos los precios seleccionados
    const totalPrice = gameState.selectedProducts.reduce((total, id) => {
        const product = products.find(p => p.id === id);
        return total + (product ? product.price : 0);
    }, 0);
    
    if (totalPrice > gameState.money) return;
    
    gameState.money -= totalPrice;
    
    // A√±adir productos al inventario del jugador usando el producto original
    gameState.selectedProducts.forEach(id => {
        const product = products.find(p => p.id === id);
        if (product &amp;&amp; product.productoOriginal) {
            player.anadirObjeto(product.productoOriginal);
        }
    });
    
    gameState.purchasedProducts = [...gameState.purchasedProducts, ...gameState.selectedProducts];
    gameState.selectedProducts = [];
    
    updateUI();
    updateInventoryDisplay();
}

/**
 * Actualiza la visualizaci√≥n del inventario en las vistas de perfil y batalla.
 * Delegate en `updateInventoryInContainer` para cada contenedor.
 * @returns {void}
 */
function updateInventoryDisplay() {
    const inventoryContainer = document.getElementById('inventory-container');
    const battleInventoryContainer = document.getElementById('battle-inventory-container');
    
    updateInventoryInContainer(inventoryContainer);
    updateInventoryInContainer(battleInventoryContainer);
}

/**
 * Rellena un contenedor con la representaci√≥n visual del inventario del jugador.
 * Se usa tanto en la escena de perfil como en el √°rea de batalla.
 * @param {HTMLElement} container - Nodo donde insertar los items.
 */
function updateInventoryInContainer(container) {
    if (!container) return;

    // Si no hay objetos, mostramos 8 casillas vac√≠as
    if (!player.inventario || player.inventario.length === 0) {
        container.innerHTML = '';
        for (let i = 0; i &lt; 8; i++) {
            const itemElement = document.createElement('div');
            itemElement.className = 'item empty';
            itemElement.id = `inventory-slot-${i}`;
            container.appendChild(itemElement);
        }
        return;
    }

    // Si hay objetos, los mostramos solo con imagen
    container.innerHTML = '';

    // FOREACH: itera sobre cada item del inventario
    player.inventario.forEach((item, index) => {
        const itemSlot = document.createElement('div');
        itemSlot.className = 'item inventory-item';

        const imageSrc = getProductImage(item);

        itemSlot.innerHTML = `
            &lt;img src="${imageSrc}" alt="${item.nombre}" class="inventory-item-img" title="${item.nombre}">
        `;

        container.appendChild(itemSlot);
    });
}

function updateStatsDisplay() {
    // No dependemos de un contenedor espec√≠fico: actualizamos los elementos disponibles en la UI
    const stats = player.mostrar();

    const statsContainer = document.getElementById('player-stats');
    if (statsContainer) {
        statsContainer.innerHTML = `
            &lt;h3>Estad√≠sticas del Jugador&lt;/h3>
            &lt;p>Nombre: ${stats.nombre}&lt;/p>
            &lt;p>Vida: ${stats.vida}/${stats.vidaMaxima}&lt;/p>
            &lt;p>Ataque: ${stats.ataque}&lt;/p>
            &lt;p>Defensa: ${stats.defensa}&lt;/p>
            &lt;p>Puntos: ${stats.puntos}&lt;/p>
            &lt;p>Inventario: ${player.inventario.length} objetos&lt;/p>
        `;
    }

    const enemyStats = document.getElementById('enemy-stats');
    if (enemyStats &amp;&amp; selectedEnemy) {
        enemyStats.innerHTML = `
            &lt;h3>Estad√≠sticas del Enemigo&lt;/h3>
            &lt;p>Nombre: ${selectedEnemy.nombre}&lt;/p>
            &lt;p>Vida: ${selectedEnemy.puntosvida}&lt;/p>
            &lt;p>Ataque: ${selectedEnemy.nivelataque}&lt;/p>
            ${selectedEnemy instanceof JefeFinal ? 
                `&lt;p>Habilidad Especial: ${selectedEnemy.habilidadespecial}&lt;/p>
                 &lt;p>Multiplicador de Da√±o: x${selectedEnemy.multiplicardanio}&lt;/p>` : ''}
        `;
    }

    // Actualizar spans individuales en las escenas (si existen)
    const atk1 = document.getElementById('stat-attack-1');
    const def1 = document.getElementById('stat-defense-1');
    const life1 = document.getElementById('stat-life-1');
    const pts1 = document.getElementById('stat-points-1');

    const atk3 = document.getElementById('stat-attack-3');
    const def3 = document.getElementById('stat-defense-3');
    const life3 = document.getElementById('stat-life-3');
    const pts3 = document.getElementById('stat-points-3');

    if (atk1) atk1.textContent = stats.ataque;
    if (def1) def1.textContent = stats.defensa;
    if (life1) life1.textContent = `${stats.vida}/${stats.vidaMaxima}`;
    if (pts1) pts1.textContent = stats.puntos;

    if (atk3) atk3.textContent = stats.ataque;
    if (def3) def3.textContent = stats.defensa;
    if (life3) life3.textContent = `${stats.vida}/${stats.vidaMaxima}`;
    if (pts3) pts3.textContent = stats.puntos;

    // final info
    const finalName = document.getElementById('final-player-name');
    const finalPoints = document.getElementById('final-points');
    if (finalName) finalName.textContent = player.nombre;
    if (finalPoints) finalPoints.textContent = player.puntos;

    // Mostrar categor√≠a final (PRO / ROOKIE) en la escena final si existe el elemento
    const finalCategoryEl = document.getElementById('final-player-category');
    if (finalCategoryEl) {
        const puntos = player.puntos || 0;
        const categoria = puntos >= 50 ? 'PRO' : 'ROOKIE';
        finalCategoryEl.textContent = categoria;
    }
}

/**
 * Crea una cola de 3 enemigos aleatorios y lanza la primera batalla.
 */
function startBattleSequence() {
    enemiesQueue = [];
    currentEnemyIndex = 0;
    
    // Seleccionar 3 enemigos aleatorios (pueden repetirse)
    // FOR: bucle tradicional para llenar la cola de enemigos
    for (let i = 0; i &lt; 3; i++) {
        const randomIdx = Math.floor(Math.random() * enemies.length);
        enemiesQueue.push(enemies[randomIdx]);
    }
    
    // Mostrar el primer enemigo
    loadNextEnemy();
}

/**
 * Carga el siguiente enemigo de la cola en la escena de batalla.
 */
function loadNextEnemy() {
    if (currentEnemyIndex >= enemiesQueue.length) {
        // Se acabaron los 3 enemigos, ir a escena final
        setTimeout(() => { 
            showScene('scene-6'); 
            updateStatsDisplay(); 
        }, 1500);
        return;
    }
    
    selectedEnemy = enemiesQueue[currentEnemyIndex];
    setBattleEnemy(selectedEnemy);
    showScene('scene-5');
    updateBattleCounter();
}

// Actualizar contador de enemigos
function updateBattleCounter() {
    const counter = document.getElementById('battle-counter');
    if (counter) {
        counter.textContent = `Enemigo ${currentEnemyIndex + 1}/3`;
    }
}

/**
 * Rellena la escena 4 con tarjetas visuales de los enemigos disponibles.
 * Es puramente informativa; la selecci√≥n real de la cola de enemigos es aleatoria.
 */
function populateEnemySelector() {
    // GETELEMENTBYID: selecciona un elemento HTML por su id
    const selectorContainer = document.getElementById('enemy-selector');
    selectorContainer.innerHTML = '';

    // FOREACH: itera sobre cada enemigo y crea su tarjeta visual
    enemies.forEach((enemy, index) => {
        const enemyCard = document.createElement('div');
        enemyCard.className = 'enemy-card';
        enemyCard.dataset.id = index;

        const enemyImage = getEnemyImage(enemy);
        const enemyInfo = `&lt;p>&lt;strong>${enemy.nombre}&lt;/strong>&lt;/p>
                          &lt;p>‚öîÔ∏è Ataque: ${enemy.nivelataque}&lt;/p>
                          &lt;p>‚ù§Ô∏è Vida: ${enemy.puntosvida}&lt;/p>`;

        enemyCard.innerHTML = `
            &lt;img src="${enemyImage}" alt="${enemy.nombre}">
            ${enemyInfo}
        `;

        selectorContainer.appendChild(enemyCard);
    });
}

/**
 * Ajusta la UI para mostrar el `enemy` actual en batalla (imagen, nombre, etc.).
 * @param {Object} enemy - Enemigo que se asigna a la batalla.
 */
function setBattleEnemy(enemy) {
    selectedEnemy = enemy;
    const enemyImg = document.getElementById('enemy-image-battle');
    const enemyName = document.getElementById('enemy-name-battle');
    if (enemyImg) enemyImg.src = getEnemyImage(enemy);
    if (enemyName) enemyName.textContent = enemy.nombre;
    
    const battleWinner = document.getElementById('battle-winner');
    if (battleWinner) battleWinner.textContent = 'Ganador: -';
    
    const battleResult = document.getElementById('battle-result');
    if (battleResult) battleResult.textContent = '';
    
    document.getElementById('fight-btn').disabled = false;
    document.getElementById('fight-btn').style.display = 'inline-block';
    
    updateStatsDisplay();
}

/**
 * Devuelve la ruta de la imagen para un enemigo seg√∫n su nombre.
 * @param {Object} enemy - Enemigo con propiedad `nombre`.
 * @returns {string} Ruta de la imagen.
 */
function getEnemyImage(enemy) {
    if (!enemy || !enemy.nombre) return './img/p1.png';
    const name = enemy.nombre.toLowerCase();
    if (name.includes('goblin')) return './img/Goblin.jpg';
    if (name.includes('lobo')) return './img/Lobo.jpg';
    if (name.includes('orco')) return './img/Orco.jpg';
    if (name.includes('demonio')) return './img/Demonio.jpg';
    if (name.includes('drag') || name.includes('drag√≥n') || name.includes('dragon')) return './img/Dragon.jpg';
    // fallback
    return './img/p1.png';
}

// Combate
/**
 * Ejecuta un turno de combate contra el `selectedEnemy` usando la funci√≥n `batalla`.
 * Muestra el resultado en la UI y avanza la cola de enemigos o finaliza la partida.
 * @returns {void}
 */
function fight() {
    if (!selectedEnemy) return;
    
    const resultado = batalla(player, selectedEnemy);
    
    const resultMessage = document.getElementById('battle-result'); // opcional
    const winnerElement = document.getElementById('battle-winner');
    const battlePointsEl = document.getElementById('battle-points');

    // Mostrar resultado y ganador
    if (resultado.ganador === 'player') {
        if (resultMessage) {
            resultMessage.textContent = '¬°Victoria! Has derrotado al enemigo';
            resultMessage.style.color = 'green';
        }
        if (winnerElement) winnerElement.textContent = `Ganador: ${player.nombre}`;
        if (battlePointsEl) battlePointsEl.textContent = player.puntos || 0;

        // Desactivar bot√≥n de lucha y avanzar al siguiente enemigo
        document.getElementById('fight-btn').disabled = true;
        currentEnemyIndex++;
        
        setTimeout(() => {
            loadNextEnemy();
        }, 1500);

    } else if (resultado.ganador === 'enemy') {
        if (resultMessage) {
            resultMessage.textContent = '¬°Has sido derrotado!';
            resultMessage.style.color = 'red';
        }
        if (winnerElement) winnerElement.textContent = `Ganador: ${selectedEnemy.nombre}`;
        if (battlePointsEl) battlePointsEl.textContent = player.puntos || 0;

        setTimeout(() => { 
            showScene('scene-6'); 
            updateStatsDisplay(); 
        }, 1500);

    } else {
        if (resultMessage) {
            resultMessage.textContent = '¬°Empate!';
            resultMessage.style.color = 'orange';
        }
        if (winnerElement) winnerElement.textContent = 'Ganador: Empate';
        if (battlePointsEl) battlePointsEl.textContent = player.puntos || 0;
        
        // En caso de empate, avanzar al siguiente enemigo despu√©s de un tiempo
        document.getElementById('fight-btn').disabled = true;
        currentEnemyIndex++;
        
        setTimeout(() => {
            loadNextEnemy();
        }, 1500);
    }
    
    console.log(resultado.detalle);
    
    updateStatsDisplay();
    document.getElementById('fight-btn').disabled = true;
}

/**
 * Reinicia el estado del juego a valores iniciales: dinero, inventario, puntos,
 * cola de enemigos y vuelve a la escena principal.
 * @returns {void}
 */
function restartGame() {
    gameState.money = initialMoney;
    gameState.selectedProducts = [];
    gameState.purchasedProducts = [];
    
    player.puntos = 0;
    player.vida = player.vidaMaxima;
    player.inventario = [];
    
    selectedEnemy = null;
    enemiesQueue = [];
    currentEnemyIndex = 0;

    initializeShop();
    initializeInventory();
    updateUI();
    showScene('scene-1');
}

// Funci√≥n para lanzar emoji de caca
/**
 * Crea y anima varios emojis (üí©) que caen por la pantalla como efecto humor√≠stico
 * usado en la escena final para jugadores 'rookie'. No devuelve nada.
 * @returns {void}
 */
function launchPoopEmojis() {
    const container = document.body;
    const poopEmoji = 'üí©';
    const duration = 3000; // 3 segundos
    const count = 30;
    
    for (let i = 0; i &lt; count; i++) {
        setTimeout(() => {
            const poop = document.createElement('div');
            poop.textContent = poopEmoji;
            poop.style.position = 'fixed';
            poop.style.left = Math.random() * 100 + '%';
            poop.style.top = '-50px';
            poop.style.fontSize = (Math.random() * 20 + 30) + 'px';
            poop.style.opacity = '1';
            poop.style.pointerEvents = 'none';
            poop.style.zIndex = '9999';
            poop.style.animation = `fallDown ${Math.random() * 2 + 2}s linear forwards`;
            
            container.appendChild(poop);
            
            setTimeout(() => poop.remove(), (Math.random() * 2 + 2) * 1000);
        }, (i / count) * 500);
    }
}

// Agregar animaci√≥n CSS para el emoji cayendo
const style = document.createElement('style');
style.textContent = `
    @keyframes fallDown {
        0% {
            transform: translateY(0) rotate(0deg);
            opacity: 1;
        }
        100% {
            transform: translateY(100vh) rotate(360deg);
            opacity: 0;
        }
    }
`;
document.head.appendChild(style);</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Jugadores.html">Jugadores</a></li><li><a href="Producto_Producto.html">Producto</a></li></ul><h3>Global</h3><ul><li><a href="global.html#applyRandomDiscount20">applyRandomDiscount20</a></li><li><a href="global.html#batalla">batalla</a></li><li><a href="global.html#canAffordProduct">canAffordProduct</a></li><li><a href="global.html#categorizePlayers">categorizePlayers</a></li><li><a href="global.html#fight">fight</a></li><li><a href="global.html#getEnemyImage">getEnemyImage</a></li><li><a href="global.html#getProductImage">getProductImage</a></li><li><a href="global.html#initializeInventory">initializeInventory</a></li><li><a href="global.html#initializeShop">initializeShop</a></li><li><a href="global.html#launchPoopEmojis">launchPoopEmojis</a></li><li><a href="global.html#loadNextEnemy">loadNextEnemy</a></li><li><a href="global.html#mostrarRanking">mostrarRanking</a></li><li><a href="global.html#mostrarReporteCompleto">mostrarReporteCompleto</a></li><li><a href="global.html#populateEnemySelector">populateEnemySelector</a></li><li><a href="global.html#processPurchase">processPurchase</a></li><li><a href="global.html#resetSelection">resetSelection</a></li><li><a href="global.html#restartGame">restartGame</a></li><li><a href="global.html#setBattleEnemy">setBattleEnemy</a></li><li><a href="global.html#showScene">showScene</a></li><li><a href="global.html#startBattleSequence">startBattleSequence</a></li><li><a href="global.html#toggleProductSelection">toggleProductSelection</a></li><li><a href="global.html#updateInventoryDisplay">updateInventoryDisplay</a></li><li><a href="global.html#updateInventoryInContainer">updateInventoryInContainer</a></li><li><a href="global.html#updateUI">updateUI</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Thu Dec 04 2025 11:05:54 GMT+0100 (hora est√°ndar de Europa central)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
